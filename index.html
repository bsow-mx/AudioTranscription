transcriptionParams.punctuate = true;
                    }
                    
                    // Add speaker detection
                    if (enableSpeakersCheckbox.checked) {
                        transcriptionParams.speaker_labels = true;
                    }
                    
                    const transcriptionId = await startTranscriptionJob(transcriptionParams);
                    
                    // Poll for results
                    const transcript = await pollTranscriptionResult(transcriptionId);
                    
                    // Update result card
                    updateResultCard(resultId, file.name, transcript);
                    
                    // Update status
                    fileStatuses.set(file.name, 'completed');
                    completedFiles++;
                    
                } catch (error) {
                    console.error(`Error processing ${file.name}:`, error);
                    
                    // Update result card with error
                    const errorCard = document.getElementById(resultId);
                    if (errorCard) {
                        errorCard.querySelector('.result-content').innerHTML = 
                            `<span class="error-message">Error: ${error.message || 'Failed to transcribe file'}</span>`;
                    } else {
                        createResultCard(
                            'error-' + Date.now(), 
                            file.name, 
                            `<span class="error-message">Error: ${error.message || 'Failed to transcribe file'}</span>`
                        );
                    }
                    
                    // Update status
                    fileStatuses.set(file.name, 'error');
                    errorFiles++;
                }
                
                // Update progress
                const progress = ((completedFiles + errorFiles) / files.length) * 100;
                progressFill.style.width = `${progress}%`;
                progressStatus.textContent = `Progress: ${completedFiles + errorFiles}/${files.length} files processed`;
                renderFileList();
            }
        }
        
        function createResultCard(id, fileName, content) {
            const resultCard = document.createElement('div');
            resultCard.className = 'result-card';
            resultCard.id = id;
            
            resultCard.innerHTML = `
                <div class="result-header">
                    <div class="result-title">${fileName}</div>
                    <div class="result-actions">
                        <button class="action-button copy-button">Copy</button>
                        <button class="action-button download-button">Download</button>
                        <button class="action-button chatgpt sendto-chatgpt-button">Send to ChatGPT</button>
                        <button class="action-button translate translate-button">Translate</button>
                        <button class="action-button summarize summarize-button">Summarize</button>
                    </div>
                </div>
                <div class="result-content">${content}</div>
            `;
            
            resultsContainer.insertBefore(resultCard, resultsContainer.firstChild);
            
            // Add event listeners
            const copyButton = resultCard.querySelector('.copy-button');
            const downloadButton = resultCard.querySelector('.download-button');
            const sendToChatGPTButton = resultCard.querySelector('.sendto-chatgpt-button');
            const translateButton = resultCard.querySelector('.translate-button');
            const summarizeButton = resultCard.querySelector('.summarize-button');
            
            copyButton.addEventListener('click', () => {
                const text = resultCard.querySelector('.result-content').textContent;
                navigator.clipboard.writeText(text)
                    .then(() => {
                        const originalText = copyButton.textContent;
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => {
                            copyButton.textContent = originalText;
                        }, 2000);
                    })
                    .catch(err => console.error('Could not copy text: ', err));
            });
            
            downloadButton.addEventListener('click', () => {
                const text = resultCard.querySelector('.result-content').textContent;
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                
                a.href = url;
                a.download = fileName.replace(/\.[^/.]+$/, '') + '_transcript.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            sendToChatGPTButton.addEventListener('click', () => {
                const text = resultCard.querySelector('.result-content').textContent;
                chatgptText.value = text;
                chatgptModal.style.display = 'flex';
                currentTranscript = text;
            });
            
            translateButton.addEventListener('click', () => {
                const text = resultCard.querySelector('.result-content').textContent;
                translateText.value = text;
                translateModal.style.display = 'flex';
                currentTranscript = text;
            });
            
            summarizeButton.addEventListener('click', () => {
                const text = resultCard.querySelector('.result-content').textContent;
                summarizeText.value = `Please summarize the following transcript concisely:\n\n${text}`;
                summarizeModal.style.display = 'flex';
                currentTranscript = text;
            });
            
            return resultCard;
        }
        
        function updateResultCard(id, fileName, content) {
            const resultCard = document.getElementById(id);
            if (resultCard) {
                resultCard.querySelector('.result-content').textContent = content || 'No transcript available';
            } else {
                createResultCard(id, fileName, content || 'No transcript available');
            }
        }
        
        // API Functions
        async function uploadFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = async (event) => {
                    try {
                        const response = await fetch('https://api.assemblyai.com/v2/upload', {
                            method: 'POST',
                            headers: {
                                'authorization': API_KEY,
                                'content-type': 'application/octet-stream'
                            },
                            body: event.target.result
                        });
                        
                        if (!response.ok) {
                            const error = await response.json().catch(() => ({}));
                            throw new Error(error.error || `Upload failed with status ${response.status}`);
                        }
                        
                        const data = await response.json();
                        resolve(data.upload_url);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsArrayBuffer(file);
            });
        }
        
        async function startTranscriptionJob(params) {
            const response = await fetch('https://api.assemblyai.com/v2/transcript', {
                method: 'POST',
                headers: {
                    'authorization': API_KEY,
                    'content-type': 'application/json'
                },
                body: JSON.stringify(params)
            });
            
            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error || `Transcription request failed with status ${response.status}`);
            }
            
            const data = await response.json();
            return data.id;
        }
        
        async function pollTranscriptionResult(transcriptId) {
            let attempts = 0;
            const maxAttempts = 100; // Avoid infinite loops
            
            while (attempts < maxAttempts) {
                attempts++;
                
                const response = await fetch(`https://api.assemblyai.com/v2/transcript/${transcriptId}`, {
                    headers: { 'authorization': API_KEY }
                });
                
                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    throw new Error(error.error || `Polling failed with status ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.status === 'completed') {
                    return data.text;
                } else if (data.status === 'error') {
                    throw new Error(data.error || 'Transcription failed');
                }
                
                // Wait before next polling attempt
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
            throw new Error('Transcription timed out');
        }
        
        // Record browser capability for mobile Safari compatibility
        const recordButton = document.createElement('button');
        recordButton.className = 'select-button';
        recordButton.style.marginLeft = '10px';
        recordButton.style.backgroundColor = '#f44336';
        recordButton.textContent = 'Record Audio';
        recordButton.style.display = 'none';
        
        // Check if browser supports recording
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            selectButton.parentNode.insertBefore(recordButton, selectButton.nextSibling);
            recordButton.style.display = 'inline-block';
            
            let mediaRecorder;
            let audioChunks = [];
            let isRecording = false;
            
            recordButton.addEventListener('click', () => {
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });
            
            async function startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        const fileName = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.wav`;
                        const file = new File([audioBlob], fileName, { type: 'audio/wav' });
                        addFiles([file]);
                        
                        // Reset recording
                        audioChunks = [];
                        isRecording = false;
                        recordButton.textContent = 'Record Audio';
                        recordButton.style.backgroundColor = '#f44336';
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    recordButton.textContent = 'Stop Recording';
                    recordButton.style.backgroundColor = '#4CAF50';
                    
                } catch (error) {
                    console.error('Error starting recording:', error);
                    alert('Could not start recording. Please allow microphone access.');
                }
            }
            
            function stopRecording() {
                if (mediaRecorder && isRecording) {
                    mediaRecorder.stop();
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                }
            }
        }
        
        // Initialize the app
        updateTranscribeButton();
    </script>
</body>
</html>
